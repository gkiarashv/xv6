![file1](https://github.com/gkiarashv/xv6/blob/main/images/unq_logic1.png)
![file1](https://github.com/gkiarashv/xv6/blob/main/images/unqlogic2.png)
![file1](https://github.com/gkiarashv/xv6/blob/main/images/unqlogic3.png)
![file1](https://github.com/gkiarashv/xv6/blob/main/images/unqlogic4.png)


## Logic
The logic in the implementation of this code is to maintain two buffers, namely `line1` and `line2`. Except for the first line which is read into `line1`, the other lines
are read into `line2`. At each step, `line1` and `line2` are compared and the passed options are processed. The comparing can be done in two ways: considering the case using `compare_str()` or ignoring the case using `compare_str_ic()`. Based on the comparison, if the two lines are not equal, we ignore it in the basic uniq command because it should be filtered and we consider it by `isRepeted=1` for the case that we have used `-d` with the uniq command. Upon reaching a different line, we have to flush out the buffers. If `-d` is used, we should only print `line1` as `line2` has content that has occurred for the first time. To print `line1` we consider the possible options passed such as `-c`. If `-d` is not used, then we consider other options such as `-c` for printing. The special case is when reaching EOF. Before reaching EOF, we have two available lines to process. After processing based on the above logic, we reach EOF. The `line1` has the last line to process because, if the two previous lines were equal, for sure, we have not printed anything. Otherwise, `line1` has been printed but `line2` not. Therefore, after pointer switching in the case of lines being not equal or `lineCount` being incremented in the case that lines are equal, the last line is `line1`. Hence, we have to process `line1` when the `readStatus == READ_EOF`.
